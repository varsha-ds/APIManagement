"""API Key management service (Postgres/SQLAlchemy)."""
from __future__ import annotations

from datetime import datetime
from typing import Optional, List, Tuple, Dict, Any

import logging
from sqlalchemy import select, update
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from app.schemas.app_client import (
    AppClientCreate, AppClientUpdate, AppClientResponse, AppClientWithSecret,
    APIKeyCreate, APIKeyResponse, APIKeyCreated
)
from app.utils.security import generate_api_key, generate_client_secret

# TODO: replace with your actual ORM imports
from app.models.app_client import AppClient, APIKey  # <- adjust

logger = logging.getLogger(__name__)


class KeyService:
    def __init__(self, session: AsyncSession):
        self.session = session

    # ---------- mapping helpers ----------

    @staticmethod
    def _client_to_response(c: AppClient) -> AppClientResponse:
        return AppClientResponse(
            id=str(c.id),
            org_id=str(c.org_id),
            name=c.name,
            description=c.description,
            client_id=c.client_id,
            is_active=c.is_active,
            created_at=c.created_at,
            updated_at=c.updated_at,
        )

    @staticmethod
    def _key_to_response(k: APIKey) -> APIKeyResponse:
        return APIKeyResponse(
            id=str(k.id),
            app_client_id=str(k.app_client_id),
            name=k.name,
            prefix=k.prefix,
            is_active=k.is_active,
            expires_at=k.expires_at,
            last_used_at=k.last_used_at,
            created_at=k.created_at,
            revoked_at=k.revoked_at,
            revoked_by=str(k.revoked_by) if k.revoked_by is not None else None,
        )

    # ================== App Clients ==================

    async def create_app_client(self, org_id: str, data: AppClientCreate) -> AppClientWithSecret:
        """
        Create a new app client with OAuth credentials.
        Returns client with secret (shown only once).
        """
        secret, secret_hash = generate_client_secret()

        c = AppClient(
            org_id=org_id,
            name=data.name,
            description=data.description,
            client_secret_hash=secret_hash,
            # client_id should be generated by the model default or here if needed
        )

        self.session.add(c)
        try:
            await self.session.commit()
        except IntegrityError:
            await self.session.rollback()
            # likely unique(org_id, name) or unique(client_id)
            raise ValueError("App client name already exists in this organization")

        await self.session.refresh(c)

        return AppClientWithSecret(
            id=str(c.id),
            org_id=str(c.org_id),
            name=c.name,
            description=c.description,
            client_id=c.client_id,
            client_secret=secret,  # shown only once
            is_active=c.is_active,
            created_at=c.created_at,
            updated_at=c.updated_at,
        )

    async def get_app_client(self, client_id: str) -> Optional[AppClientResponse]:
        """Get app client by internal ID (not OAuth client_id)."""
        res = await self.session.execute(select(AppClient).where(AppClient.id == client_id))
        c = res.scalar_one_or_none()
        return self._client_to_response(c) if c else None

    async def get_app_client_by_oauth_id(self, oauth_client_id: str) -> Optional[dict]:
        """
        Get app client by OAuth client_id (for authentication).
        NOTE: returns dict-like info needed for auth; includes secret hash.
        """
        res = await self.session.execute(select(AppClient).where(AppClient.client_id == oauth_client_id))
        c = res.scalar_one_or_none()
        if not c:
            return None
        return {
            "id": str(c.id),
            "org_id": str(c.org_id),
            "client_id": c.client_id,
            "client_secret_hash": c.client_secret_hash,
            "is_active": c.is_active,
        }

    async def list_app_clients(
        self,
        org_id: str,
        is_active: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[AppClientResponse]:
        stmt = select(AppClient).where(AppClient.org_id == org_id)
        if is_active is not None:
            stmt = stmt.where(AppClient.is_active == is_active)

        stmt = stmt.order_by(AppClient.created_at.desc()).offset(offset).limit(limit)
        res = await self.session.execute(stmt)
        return [self._client_to_response(c) for c in res.scalars().all()]

    async def update_app_client(self, client_id: str, data: AppClientUpdate) -> Optional[AppClientResponse]:
        values: Dict[str, Any] = {"updated_at": datetime.utcnow()}
        if data.name is not None:
            values["name"] = data.name
        if data.description is not None:
            values["description"] = data.description
        if data.is_active is not None:
            values["is_active"] = data.is_active

        stmt = (
            update(AppClient)
            .where(AppClient.id == client_id)
            .values(**values)
            .returning(AppClient)
        )
        try:
            res = await self.session.execute(stmt)
            row = res.fetchone()
            if not row:
                await self.session.rollback()
                return None
            await self.session.commit()
            return self._client_to_response(row[0])
        except IntegrityError:
            await self.session.rollback()
            raise ValueError("App client name already exists in this organization")

    async def rotate_client_secret(self, client_id: str) -> Tuple[str, str]:
        """
        Rotate OAuth client secret.
        Returns: (client_id, new_secret) - secret shown only once
        """
        res = await self.session.execute(select(AppClient).where(AppClient.id == client_id))
        c = res.scalar_one_or_none()
        if not c:
            raise ValueError("App client not found")

        new_secret, secret_hash = generate_client_secret()

        c.client_secret_hash = secret_hash
        c.updated_at = datetime.utcnow()

        await self.session.commit()
        return c.client_id, new_secret

    async def deactivate_app_client(self, client_id: str) -> bool:
        """Deactivate an app client and revoke all its API keys (atomic)."""
        # Transactional approach: update client + keys before commit
        res = await self.session.execute(select(AppClient).where(AppClient.id == client_id))
        c = res.scalar_one_or_none()
        if not c:
            return False

        c.is_active = False
        c.updated_at = datetime.utcnow()

        # revoke keys for that client
        await self.session.execute(
            update(APIKey)
            .where(APIKey.app_client_id == client_id, APIKey.is_active == True)  # noqa: E712
            .values(
                is_active=False,
                revoked_at=datetime.utcnow(),
            )
        )

        await self.session.commit()
        return True

    # ================== API Keys ==================

    async def create_api_key(self, app_client_id: str, data: APIKeyCreate) -> APIKeyCreated:
        """
        Create a new API key for an app client.
        Returns key with full plaintext (shown only once).
        """
        res = await self.session.execute(select(AppClient).where(AppClient.id == app_client_id))
        c = res.scalar_one_or_none()
        if not c:
            raise ValueError("App client not found")
        if not c.is_active:
            raise ValueError("App client is inactive")

        full_key, prefix, key_hash = generate_api_key()

        k = APIKey(
            app_client_id=app_client_id,
            name=data.name,
            prefix=prefix,
            key_hash=key_hash,
            expires_at=data.expires_at,
            is_active=True,
        )
        self.session.add(k)

        try:
            await self.session.commit()
        except IntegrityError:
            await self.session.rollback()
            # could be unique(app_client_id, name) or other
            raise ValueError("API key already exists")

        await self.session.refresh(k)

        return APIKeyCreated(
            id=str(k.id),
            app_client_id=str(k.app_client_id),
            name=k.name,
            prefix=k.prefix,
            api_key=full_key,  # shown only once
            is_active=k.is_active,
            expires_at=k.expires_at,
            last_used_at=k.last_used_at,
            created_at=k.created_at,
        )

    async def get_api_key(self, key_id: str) -> Optional[APIKeyResponse]:
        res = await self.session.execute(select(APIKey).where(APIKey.id == key_id))
        k = res.scalar_one_or_none()
        return self._key_to_response(k) if k else None

    async def list_api_keys(
        self,
        app_client_id: str,
        is_active: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[APIKeyResponse]:
        stmt = select(APIKey).where(APIKey.app_client_id == app_client_id)
        if is_active is not None:
            stmt = stmt.where(APIKey.is_active == is_active)

        stmt = stmt.order_by(APIKey.created_at.desc()).offset(offset).limit(limit)
        res = await self.session.execute(stmt)
        return [self._key_to_response(k) for k in res.scalars().all()]

    async def rotate_api_key(self, key_id: str) -> APIKeyCreated:
        """
        Rotate an API key - revokes old and creates new (atomic).
        Returns new key with plaintext (shown only once).
        """
        res = await self.session.execute(select(APIKey).where(APIKey.id == key_id))
        old = res.scalar_one_or_none()
        if not old:
            raise ValueError("API key not found")

        # revoke old
        old.is_active = False
        old.revoked_at = datetime.utcnow()

        # create new
        full_key, prefix, key_hash = generate_api_key()
        new_key = APIKey(
            app_client_id=old.app_client_id,
            name=f"{old.name} (rotated)",
            prefix=prefix,
            key_hash=key_hash,
            expires_at=old.expires_at,
            is_active=True,
        )
        self.session.add(new_key)

        await self.session.commit()
        await self.session.refresh(new_key)

        return APIKeyCreated(
            id=str(new_key.id),
            app_client_id=str(new_key.app_client_id),
            name=new_key.name,
            prefix=new_key.prefix,
            api_key=full_key,
            is_active=new_key.is_active,
            expires_at=new_key.expires_at,
            last_used_at=new_key.last_used_at,
            created_at=new_key.created_at,
        )

    async def revoke_api_key(self, key_id: str, revoked_by: Optional[str] = None) -> bool:
        res = await self.session.execute(select(APIKey).where(APIKey.id == key_id))
        k = res.scalar_one_or_none()
        if not k:
            return False

        k.is_active = False
        k.revoked_at = datetime.utcnow()
        if hasattr(k, "revoked_by"):
            k.revoked_by = revoked_by

        await self.session.commit()
        return True

    async def list_all_keys_admin(
        self,
        org_id: Optional[str] = None,
        is_active: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[dict]:
        """
        Admin view: join api_keys + app_clients.
        Never return key_hash or client_secret_hash.
        """
        stmt = select(APIKey, AppClient).join(AppClient, APIKey.app_client_id == AppClient.id)

        if org_id:
            stmt = stmt.where(AppClient.org_id == org_id)
        if is_active is not None:
            stmt = stmt.where(APIKey.is_active == is_active)

        stmt = stmt.order_by(APIKey.created_at.desc()).offset(offset).limit(limit)
        res = await self.session.execute(stmt)

        out: List[dict] = []
        for k, c in res.all():
            out.append({
                "id": str(k.id),
                "app_client_id": str(k.app_client_id),
                "name": k.name,
                "prefix": k.prefix,
                "is_active": k.is_active,
                "expires_at": k.expires_at,
                "last_used_at": k.last_used_at,
                "created_at": k.created_at,
                "revoked_at": k.revoked_at,
                "revoked_by": str(k.revoked_by) if getattr(k, "revoked_by", None) else None,
                "client": {
                    "id": str(c.id),
                    "org_id": str(c.org_id),
                    "name": c.name,
                    "description": c.description,
                    "client_id": c.client_id,
                    "is_active": c.is_active,
                    "created_at": c.created_at,
                    "updated_at": c.updated_at,
                }
            })
        return out
